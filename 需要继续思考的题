95. Unique Binary Search Trees II 考虑DP做法
130. Surrounded Regions 参考下别人的uion-find做法
163. Missing Ranges   最简洁解法
191. Number of 1 Bits
254. Factor Combinations  思路不清晰，解法不明确，时间复杂度不太明确
255. Verify Preorder Sequence in Binary Search Tree 空间O(n)方法
261. Graph Valid Tree 高效解法  union-find解法
287. Find the Duplicate Number  O(n)解法
300. Longest Increasing Subsequence   O(nlogn)解法
320. Generalized Abbreviation   permutation解法
323. Number of Connected Components in an Undirected Graph  union-find解法
324. Wiggle Sort II 最优解法
377. Combination Sum IV 它的follow up
400. Nth Digit 将代码写得更简洁，思路理清
406. Queue Reconstruction by Height
410. Split Array Largest Sum  二叉搜索解法
416. Partition Equal Subset Sum 考虑用dfs做
422. Valid Word Square  考虑更简洁的写法
439. Ternary Expression Parser  考虑用stack做
486. Predict the Winner 搞清楚它的DP解
536. Construct Binary Tree from String  迭代方法
641. Design Circular Deque  单vector的写法
645. Set Mismatch O(1)space的方法

685. Redundant Connection II  考虑如何将union-find应用到有向图中

752. Open the Lock  需要继续考虑效率更高的写法（双向BFS)，并且考虑下什么时候在访问节点之前就将其放入visited中。
776. Split BST  需要理解方法
869. Reordered Power of 2 考虑更好的解法
886. Possible Bipartition 具体要思考的问题看该题的github文档
907. Sum of Subarray Minimums 考虑如何用单调stack去解决
918. Maximum Sum Circular Subarray 更优的解法
923. 3Sum With Multiplicity 更高效的方法
1048. Longest String Chain  尝试用DFS去解决



2019.10.29
137. Single Number II
215. Kth Largest Element in an Array
260. Single Number III
545. Boundary of Binary Tree
698. Partition to K Equal Sum Subsets
767. Reorganize String
909. Snakes and Ladders
957. Prison Cells After N Days
973. K Closest Points to Origin(用快速排序的方法)
983. Minimum Cost For Tickets







