95. Unique Binary Search Trees II   Dp解法
163. Missing Ranges   最简洁解法
191. Number of 1 Bits
254. Factor Combinations  思路不清晰，解法不明确，时间复杂度不太明确
255. Verify Preorder Sequence in Binary Search Tree 空间O(n)方法
261. Graph Valid Tree 高效解法
287. Find the Duplicate Number  O(n)解法
300. Longest Increasing Subsequence   O(nlogn)解法
320. Generalized Abbreviation   permutation解法
324. Wiggle Sort II 最优解法
377. Combination Sum IV 它的follow up
400. Nth Digit 将代码写得更简洁，思路理清
406. Queue Reconstruction by Height
416. Partition Equal Subset Sum 考虑用dfs做
439. Ternary Expression Parser  考虑用stack做
474. Ones and Zeroes  需要总结下0-1背包问题，包括基本写法，优化，从上至下以及从下至上(416类似）
536. Construct Binary Tree from String  迭代方法
641. Design Circular Deque  单vector的写法
645. Set Mismatch O(1)space的方法
752. Open the Lock  需要继续考虑效率更高的写法（双向BFS)，并且考虑下什么时候在访问节点之前就将其放入visited中。
776. Split BST  需要理解方法
886. Possible Bipartition 具体要思考的问题看该题的github文档
907. Sum of Subarray Minimums 考虑如何用单调stack去解决
918. Maximum Sum Circular Subarray 更优的解法
923. 3Sum With Multiplicity 更高效的方法
1048. Longest String Chain  尝试用DFS去解决



