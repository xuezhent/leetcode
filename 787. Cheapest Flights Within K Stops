class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {
        vector<int> c(n, 1e8);
        c[src] = 0;
        
        for(int i = 0; i <= K; i++) {            
            vector<int> C(c);
            for(auto e: flights)
                C[e[1]] = min(C[e[1]], c[e[0]] + e[2]);
            c = C;           
        }
        
        return c[dst] == 1e8 ? -1 : c[dst];
    }
};

这是这道题的bellman ford解法，我们再看下一般的bellman ford解法是什么样的。

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        vector<int> d(N+1, INT_MAX);
        d[K] = 0;
        for(int i = 0; i < N; i++) {
            for(auto& t : times) {
                if(d[t[0]] == INT_MAX)  continue;
                int tmp = d[t[0]] + t[2];
                if(tmp < d[t[1]])   d[t[1]] = tmp;
            }
        }
        
        int res = 0;
        for(int i = 1; i <= N; i++)   res = max(res, d[i]);
        return res == INT_MAX ? -1 : res;
    }
};

这是743题的代码，我们可以看下7-12行与25-31行的区别，可以发现第8行是用到了一个临时的vector去存每一轮的结果，但是在下面这个方法中，并没有这样做。
那么区别在于什么地方呢？我们设想一个例子，[[0,1,100],[1,2,100],[0,2,500]]，有三条边，0->1，权重为100，其他两条边类似，要求最多一条边。
如果是第二种方案，当只能循环一轮的时候，初始，d[0]为0，d[1],d[2]均为正无穷，第一条边和第二条边的遍历，会让d[2]变成200，这时候再访问第三条边，不会
改变d[2]的值了。但是这是我们想要的吗？这明显经过了两条边。什么问题造成了这个结果？在某一轮中，我可能会使用到这一轮中之前的计算结果，这会导致最终经过
的边的数量会偏多。但是这在一般的单源最短路径中是不是一个问题？并不是，因为一般的单源最短路径问题可以将可经过的边看成是无限大，也就是没有限制，但最多的
话，也就是把所有的边都用上。但是对于这个题目来说，这就有问题了，它是对所经过的边的数量是有一个明确的要求的。那么如何解决呢？
我们来看下上面的情况，就是如果我们用到了同一轮中的结果，那么我们是会出现这个问题，那么我们只能运用上一轮的结果。那么就需要用到这个临时vector去存每一
轮的结果。
我们在把这个结果好好梳理一下，为什么每增加一轮循环，就相当于将可能的最长路径增加了1呢？为什么在进行bellman ford算法的时候，最多也就进行N轮呢（N为
边的数量）？
那么我们首先看下初始情况下，d[0]为0，然后其他的点均为正无穷，这是边为0的状态。那么我们再看下有一条边，那么和0连着的所有的点都不再是正无穷了。那么我们
再看有两条边，对于一个点来说，它无非两种情况，一种是它到0的距离已经不是正无穷；另一种距离还是正无穷。那么第一种情况，表示它和0之间存在一条距离小于2的
路径，第二种情况，表示它和0之间不存在距离小于2的路径，那如果这个时候它到0的距离被更新了，就说明这个点到0之间存在一条距离为2的路径。那么距离为K，情况
就与此类似。


